# Aptamer-Project
A repository for code written during my internship at Frederick National Labs, working on potential RNA Aptamers for the protein PrPc (bovine prion protein).

Summary: The project aims to propose RNA sequences (aptamers) which bind to a target protein, ‘PrPc’ (bovine prion) with high affinity, starting from an experimental sequence ‘2RU7’ (https://www.rcsb.org/structure/2ru7). This involves modelling the structure of 2RU7, using both secondary and tertiary structure prediction programs such as ViennaRNA, Unafold, RNAComposer and iCn3D; and modelling the protein-RNA complex, to be done via rigid body docking simulations using the existing PDB structures, and also molecular dynamic simulations. The aim is then to propose aptamers which produce similar secondary and tertiary structure, and assess their binding. For candidate aptamers, compare substrate-binding affinities with ‘2RU7’, aiming to " beat the current standard”.

Apta-MCTS (https://github.com/leekh7411/Apta-MCTS) generates a large number of potential RNA aptamer sequences, which may bind with good affinity to a target peptide. It's proposed as an 'in-silico' alternative to SELEX, the process of generating a large number of physical aptamer sequences, which is highly expensive and time-consuming. It instead uses a Random Forest model trained on preexisting Aptamer-Protein Interaction(API) data, and generates candidates via a Monte Carlo Tree Search algorithm. The program is not deterministic, which presents a problem in determining the ideal aptamer sequences to move forward with into docking simulations.

1. Apta-MCTS_and_TN93_Exploration: My initial exploration of the behaviour of the program. My mentor was interested to know whether the tree search algorithm might produce the same set of aptamers if fed the same input conditions, and to what degree. Is it completely deterministic, does it produce some recurring sequences in each batch, or is it entirely new each time? To what extent does this depend on the aptamer length, n(size of search space is 4^n)? Finding was that the algorithm is highly unlikely to **exactly** duplicate a sequence. From this, we get into methods of trying to quantify how similar related sequences are, and to gain information from these relationships. To do so, I imported the TN93 model (https://github.com/CDCgov/tn93), which is a fairly widely used measure of distance by nucleotide substitution. Finding was that even though Apta-MCTS rarely duplicates the same candidate exactly, it does frequently create candidates which differ only by a few substitutes.
   
2. Clustering by Pairwise Tamura-Nei Score: Building an [n x n] matrix, what we now have are pairwise interaction scores for each pair of aptamers in the set, enabling us to cluster based on pairwise scores, and ideally selecting the aptamer in the cluster with the highest API score. Thinking about clustering in general (eg. using RNAseq data), the idea is to calculate pairwise distances in a high-dimensional "Euclidean" space, using the individual columns as dimensions. These Tamura-Nei distances are essentially high-dimensional! The distance between a pair of nucleotide strings is calculated from the individual distances of the bases in each position. So, think of a 15-base sequence as being 15-dimensional.
Using agglomerative clustering from scikit-learn, I made a nice dendrogram. For further descriptive power, I added the raw sequences, their API scores and which iteration of Apta-MCTS they come from, as labels. In some of the groups, the sequences seemed to be very similar, providing confidence in the pairwise arrangement, other groups seemed to be sort of "catch-all". Some groups also contain "clumps" of very high API sequences, particularly the red group. Hence, proof that the API scores of related sequences are also often correlated, which is helpful. Regarding iteration, I see that some groups and sections of a group contain sequences all from the same run. I interpret this as being that the program seems to generate a few families of related candidate sequences. But! It may run into those families multiple times, on different runs of the program. In other words **finding the best aptamers is an optimization problem, towards a finite number of optimal solutions**.
   
   **3. Kill-Neighbors:** 

5. Kill-Neighbors(Operationalized): 
   
6. Application to Real Data (12b):
   
7. Application to Real Data (15b):
