# Aptamer-Project
A repository for code written during my internship at Frederick National Labs, working on potential RNA Aptamers for the protein PrPc (bovine prion protein).

Summary: The project aims to propose RNA sequences (aptamers) which bind to a target protein, ‘PrPc’ (bovine prion) with high affinity, starting from an experimental sequence ‘2RU7’ (https://www.rcsb.org/structure/2ru7). This involves modelling the structure of 2RU7, using both secondary and tertiary structure prediction programs such as ViennaRNA, Unafold, RNAComposer and iCn3D; and modelling the protein-RNA complex, to be done via rigid body docking simulations using the existing PDB structures, and also molecular dynamic simulations. The aim is then to propose aptamers which produce similar secondary and tertiary structure, and assess their binding. For candidate aptamers, compare substrate-binding affinities with ‘2RU7’, aiming to " beat the current standard”.

Apta-MCTS (https://github.com/leekh7411/Apta-MCTS) generates a large number of potential RNA aptamer sequences, which may bind with good affinity to a target peptide. It's proposed as an 'in-silico' alternative to SELEX, the process of generating a large number of physical aptamer sequences, which is highly expensive and time-consuming. It instead uses a Random Forest model trained on preexisting Aptamer-Protein Interaction(API) data, and generates candidates via a Monte Carlo Tree Search algorithm. The program is not deterministic, which presents a problem in determining the ideal aptamer sequences to move forward with into docking simulations.

1. Apta-MCTS_and_TN93_Exploration: My initial exploration of the behaviour of the program. My mentor was interested to know whether the tree search algorithm might produce the same set of aptamers if fed the same input conditions, and to what degree. Is it completely deterministic, does it produce some recurring sequences in each batch, or is it entirely new each time? To what extent does this depend on the aptamer length, n(size of search space is 4^n)? Finding was that the algorithm is highly unlikely to **exactly** duplicate a sequence. From this, we get into methods of trying to quantify how similar related sequences are, and to gain information from these relationships. To do so, I imported the TN93 model (https://github.com/CDCgov/tn93), which is a fairly widely used measure of distance by nucleotide substitution. Finding was that even though Apta-MCTS rarely duplicates the same candidate exactly, it does frequently create candidates which differ only by a few substitutes.
   
2. Clustering by Pairwise Tamura-Nei Score: Building an [n x n] matrix, what we now have are pairwise interaction scores for each pair of aptamers in the set, enabling us to cluster based on pairwise scores, and ideally selecting the aptamer in the cluster with the highest API score. Thinking about clustering in general (eg. using RNAseq data), the idea is to calculate pairwise distances in a high-dimensional "Euclidean" space, using the individual columns as dimensions. These Tamura-Nei distances are essentially high-dimensional! The distance between a pair of nucleotide strings is calculated from the individual distances of the bases in each position. So, think of a 15-base sequence as being 15-dimensional.
Using agglomerative clustering from scikit-learn, I made a nice dendrogram. For further descriptive power, I added the raw sequences, their API scores and which iteration of Apta-MCTS they come from, as labels. In some of the groups, the sequences seemed to be very similar, providing confidence in the pairwise arrangement, other groups seemed to be sort of "catch-all". Some groups also contain "clumps" of very high API sequences, particularly the red group. Hence, proof that the API scores of related sequences are also often correlated, which is helpful. Regarding iteration, I see that some groups and sections of a group contain sequences all from the same run. I interpret this as being that the program seems to generate a few families of related candidate sequences. But! It may run into those families multiple times, on different runs of the program. In other words **finding the best aptamers is an optimization problem, towards a finite number of optimal solutions**.
   
   **3. Kill-Neighbors:** A fairly complex function intended to take in a large number of candidate aptamer sequences, and iteratively weed out sub-optimal sequences, based on their proximity to sequences with higher API scores. To do so, it utilizes the pairwise Tamura-Nei distance matrix to generate a "neighborhood" around each sequence. That is, the set of sequences which are within a particular cutoff distance, to be considered neighbors. It then adds some sequences to a list of sequences to be pruned, based on one of a few different algorithms (amenable to later improvement). Most intuitive is 'API_E': Take all sequences which have the lowest API score in their own neighborhood, and of those, add those which have the largest neighborhood size to the list. Doing this, you will eventually get to the point where only neighborhoods with all the same API-score exist, which are called "impasse solutions". The '_E' suffix means that if these exist, they can be further pruned by selecting for the lowest free energy change. The function takes as optional arguments: a. Tamura-Nei distance cutoff. b. Cutting algorithm. c. Limit/Maximum number of rounds.
The purpose of creating such a function, rather than simply selecting the top sequences to move forward, is to be able to distinguish between a large number of related sequences, and to be able to thin them out to the extent required based on the requirements for further work.

5. Kill-Neighbors Algorithm(Operationalized): **^The above code, but with all the exploratory steps removed.**
   
6. Application to Real Data (12b & 15b): Application of the 'Kill_Neighbors' algorithm to retrieve candidate aptamers. Either set contains 5000 sequences, generated by Apta-MCTS in 50 rounds. The result, in either case, is 14-15 candidates!

Further work: Assessment of candidates via docking, to prove that high API scores correlate well with the results of docking simulations. Further explorations into how to improve the 'Kill_Neighbors' function. 
